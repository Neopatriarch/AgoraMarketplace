// Filepath: src/components/SingleEventView.tsx
// Author: Robert Kirkpatrick
// Generated by: Venice AI
// v1.0.3 - Removed orphaned code to fix syntax error.

import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { DateTime } from 'luxon';
import * as nostrTools from 'nostr-tools';

// --- Constants ---
const RELAYS = ['wss://relay.damus.io', 'wss://nos.lol', 'wss://relay.snort.social'];
const TIMEOUT_MS = 5000;

// --- Component Definition ---
interface SingleEventViewProps {
  userPublicKey?: string; // Added to accept prop from App.tsx
}

const SingleEventView: React.FC<SingleEventViewProps> = ({ userPublicKey }) => {
  const { eventId } = useParams<{ eventId: string }>();
  const navigate = useNavigate();
  const [event, setEvent] = useState<any | null>(null);
  const [hostProfile, _setHostProfile] = useState<any | null>(null); // Prefixed to be unused
  const [comments, setComments] = useState<any[]>([]);
  const [commenterProfiles, setCommenterProfiles] = useState<{ [key: string]: any }>({});
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [newComment, setNewComment] = useState('');
  const [isPostingComment, setIsPostingComment] = useState(false);

  useEffect(() => {
    if (!eventId) {
      setError('No event ID provided.');
      setIsLoading(false);
      return;
    }

    const fetchEventAndData = async () => {
      setIsLoading(true);
      try {
        let fetchedEvent: any = null;
        for (const relayUrl of RELAYS) {
          try {
            fetchedEvent = await new Promise<any>((resolve, reject) => {
              const socket = new WebSocket(relayUrl);
              const timeoutId = setTimeout(() => { console.log(`⏱️ Timeout for ${relayUrl} fetching single event.`); socket.close(); reject(new Error('Timeout')); }, TIMEOUT_MS);
              socket.onopen = () => { clearTimeout(timeoutId); socket.send(JSON.stringify(["REQ", `event-${eventId}`, { ids: [eventId] }])); };
              socket.onmessage = (msg) => {
                const data = JSON.parse(msg.data);
                if (data[0] === 'EVENT' && data[2] && data[2].id === eventId) { clearTimeout(timeoutId); socket.close(); resolve(data[2]); }
                if (data[0] === 'EOSE') { clearTimeout(timeoutId); socket.close(); reject(new Error('Event not found on this relay')); }
              };
              socket.onerror = () => { clearTimeout(timeoutId); socket.close(); reject(new Error('Connection error')); };
            });
            break;
          } catch (e) { /* continue */ }
        }
        if (!fetchedEvent) { throw new Error('Event not found on any relay.'); }
        setEvent(fetchedEvent);
        
        const hostPubkey = fetchedEvent.pubkey;
        let hostProfileData: any = null;
        for (const relayUrl of RELAYS) {
          try {
            hostProfileData = await new Promise<any>((resolve, reject) => {
              const socket = new WebSocket(relayUrl);
              const timeoutId = setTimeout(() => { console.log(`⏱️ Timeout for ${relayUrl} fetching host profile.`); socket.close(); reject(new Error('Timeout')); }, TIMEOUT_MS);
              socket.onopen = () => { clearTimeout(timeoutId); socket.send(JSON.stringify(["REQ", `profile-${hostPubkey.substring(0,8)}`, { kinds: [0], authors: [hostPubkey], limit: 1 }])); };
              socket.onmessage = (msg) => {
                const data = JSON.parse(msg.data);
                if (data[0] === 'EVENT' && data[2] && data[2].kind === 0) { clearTimeout(timeoutId); socket.close(); resolve(JSON.parse(data[2].content)); }
                if (data[0] === 'EOSE') { clearTimeout(timeoutId); socket.close(); reject(new Error('Profile not found on this relay')); }
              };
              socket.onerror = () => { clearTimeout(timeoutId); socket.close(); reject(new Error('Connection error')); };
            });
            break;
          } catch (e) { /* continue */ }
        }
        _setHostProfile(hostProfileData);

        const allCommentsMap = new Map<string, any>();
        const commenterPubkeys = new Set<string>();
        for (const relayUrl of RELAYS) {
          try {
            await new Promise<void>((resolve) => {
              const socket = new WebSocket(relayUrl);
              const timeoutId = setTimeout(() => { console.log(`⏱️ Timeout for ${relayUrl} fetching comments.`); socket.close(); resolve(); }, TIMEOUT_MS);
              socket.onopen = () => { clearTimeout(timeoutId); socket.send(JSON.stringify(["REQ", "comments", { kinds: [1], '#e': [eventId] }])); };
              socket.onmessage = (msg) => {
                const data = JSON.parse(msg.data);
                if (data[0] === 'EVENT' && data[2] && data[2].kind === 1) {
                  const comment = data[2];
                  allCommentsMap.set(comment.id, comment);
                  commenterPubkeys.add(comment.pubkey);
                }
                if (data[0] === 'EOSE') { clearTimeout(timeoutId); socket.close(); resolve(); }
              };
              socket.onerror = () => { clearTimeout(timeoutId); socket.close(); resolve(); };
            });
          } catch (e) { console.warn(e); }
        }
        const commentsArray = Array.from(allCommentsMap.values()).sort((a, b) => a.created_at - b.created_at);
        setComments(commentsArray);

        const profiles: { [key: string]: any } = {};
        for (const pubkey of commenterPubkeys) {
          for (const relayUrl of RELAYS) {
            try {
              const profileData = await new Promise<any>((resolve, reject) => {
                const socket = new WebSocket(relayUrl);
                const timeoutId = setTimeout(() => { console.log(`⏱️ Timeout for ${relayUrl} fetching commenter profile.`); socket.close(); reject(new Error('Timeout')); }, TIMEOUT_MS);
                socket.onopen = () => { clearTimeout(timeoutId); socket.send(JSON.stringify(["REQ", `profile-${pubkey.substring(0,8)}`, { kinds: [0], authors: [pubkey], limit: 1 }])); };
                socket.onmessage = (msg) => {
                  const data = JSON.parse(msg.data);
                  if (data[0] === 'EVENT' && data[2] && data[2].kind === 0) { clearTimeout(timeoutId); socket.close(); resolve(JSON.parse(data[2].content)); }
                  if (data[0] === 'EOSE') { clearTimeout(timeoutId); socket.close(); reject(new Error('Profile not found on this relay')); }
                };
                socket.onerror = () => { clearTimeout(timeoutId); socket.close(); reject(new Error('Connection error')); };
              });
              profiles[pubkey] = profileData;
              break;
            } catch (e) { /* continue */ }
          }
        }
        setCommenterProfiles(profiles);

      } catch (err) {
        console.error("Failed to fetch event data:", err);
        setError((err as Error).message || 'An unknown error occurred.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchEventAndData();
  }, [eventId]);

  const handlePostComment = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newComment.trim() || !userPublicKey) return;
    setIsPostingComment(true);
    try {
      const storedPrivateKey = localStorage.getItem('agora_privateKey');
      let signedEvent;
      if (storedPrivateKey) {
        signedEvent = nostrTools.finalizeEvent({
          created_at: Math.floor(Date.now() / 1000), kind: 1, tags: [['e', eventId!], ['p', userPublicKey]], content: newComment
        }, nostrTools.utils.hexToBytes(storedPrivateKey));
      } else if (window.nostr) {
        signedEvent = await window.nostr.signEvent({ created_at: Math.floor(Date.now() / 1000), kind: 1, tags: [['e', eventId!], ['p', userPublicKey]], content: newComment });
      } else {
        alert('Cannot sign action.');
        setIsPostingComment(false);
        return;
      }
      for (const relayUrl of RELAYS) {
        try { await new Promise<void>((resolve) => { const socket = new WebSocket(relayUrl); socket.onopen = () => { socket.send(JSON.stringify(["EVENT", signedEvent])); setTimeout(() => { socket.close(); resolve(); }, 500); }; socket.onerror = () => { socket.close(); resolve(); }; }); } catch (e) { console.warn(e); }
      }
      setNewComment('');
      window.location.reload();
    } catch (err) {
      console.error("Failed to post comment:", err);
      setError('Failed to post comment.');
    } finally {
      setIsPostingComment(false);
    }
  };

  if (isLoading) return <div>Loading event...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!event) return <div>Event not found.</div>;

  const eventData = JSON.parse(event.content);
  const startTime = DateTime.fromISO(eventData.startTime);
  const getCommenterName = (pubkey: string) => commenterProfiles[pubkey]?.name || pubkey.substring(0, 8) + '...';

  return (
    <div style={{ padding: '20px' }}>
      <button onClick={() => navigate(-1)} style={{ marginBottom: '20px' }}>← Back</button>
      {eventData.image_url && <img src={eventData.image_url} alt={eventData.name} style={{ maxWidth: '100%', height: 'auto', borderRadius: '8px' }} />}
      <h1>{eventData.name}</h1>
      <p><strong>Hosted by:</strong> {hostProfile?.name || event.pubkey.substring(0, 8) + '...'}</p>
      <p><strong>Where:</strong> {eventData.location}</p>
      <p><strong>When:</strong> {startTime.toLocaleString(DateTime.DATETIME_FULL)}</p>
      <p style={{ whiteSpace: 'pre-wrap' }}>{eventData.description}</p>

      <div style={{ marginTop: '40px' }}>
        <h3>Comments</h3>
        <form onSubmit={handlePostComment}>
          <textarea
            value={newComment}
            onChange={(e) => setNewComment(e.target.value)}
            placeholder="Write a comment..."
            rows={3}
            required
            disabled={isPostingComment}
            style={{ width: '100%', marginBottom: '10px' }}
          ></textarea>
          <button type="submit" disabled={isPostingComment}>
            {isPostingComment ? 'Posting...' : 'Post Comment'}
          </button>
        </form>
        {comments.map(comment => (
          <div key={comment.id} style={{ border: '1px solid #eee', padding: '10px', marginTop: '10px', borderRadius: '8px' }}>
            <strong>{getCommenterName(comment.pubkey)}</strong>
            <span style={{ marginLeft: '10px', color: '#888' }}>{DateTime.fromSeconds(comment.created_at).toRelative()}</span>
            <p style={{ marginTop: '5px', whiteSpace: 'pre-wrap' }}>{comment.content}</p>
          </div>
        ))}
      </div>
    </div>
  );
};

export default SingleEventView;

// --- End of File ---
// Filepath: src/components/SingleEventView.tsx
// Version: v1.0.3
