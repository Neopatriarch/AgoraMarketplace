// Filepath: src/hooks/useAgoraData.ts
// Author: Robert Kirkpatrick
// Generated by: Venice AI
// v1.0.10 - Fixed all remaining TypeScript build errors, including private key type conversion.

import { useState, useEffect } from 'react';
import { DateTime } from 'luxon';
import * as nostrTools from 'nostr-tools';

// --- Constants ---
const RELAYS = ['wss://relay.damus.io', 'wss://nos.lol', 'wss://relay.snort.social'];
const EVENTS_PER_PAGE = 10;
const TIMEOUT_MS = 5000;

// --- Custom Hook Definition ---
/**
 * A custom React hook that manages all data fetching, state, and event handling
 * for the Agora Marketplace application.
 * @param userPublicKey The logged-in user's public key.
 * @returns An object containing all state and handler functions needed by the UI.
 */
export const useAgoraData = (userPublicKey: string) => {
    // --- State Management ---
    const [events, setEvents] = useState<any[]>([]);
    const [hostProfiles, setHostProfiles] = useState<{ [key: string]: any }>({});
    const [commenterProfiles, setCommenterProfiles] = useState<{ [key: string]: any }>({});
    const [friends, setFriends] = useState<Set<string>>(new Set());
    const [rsvps, setRsvps] = useState<{ [eventId: string]: Set<string> }>({});
    const [comments, setComments] = useState<{ [eventId: string]: any[] }>({});
    const [isLoading, setIsLoading] = useState(true);
    const [isLoadingMore, setIsLoadingMore] = useState(false);
    const [hasMoreEvents, setHasMoreEvents] = useState(true);
    const [error, setError] = useState<string | null>(null);

    // --- Data Fetching & Processing ---

    const clearError = () => setError(null);

    const processNewEvents = async (newEvents: any[]) => {
        if (newEvents.length < EVENTS_PER_PAGE) setHasMoreEvents(false);
        if (newEvents.length === 0) return;
        const eventIds = newEvents.map(e => e.id);
        await Promise.all([
            fetchProfilesFromRelaysWithTimeout(newEvents),
            fetchRSVPsAndCancellations(eventIds),
            fetchCommentsForEvents(eventIds)
        ]);
    };

    const fetchEventsWithTimeout = async (until?: number): Promise<any[]> => {
        const allEvents: any[] = [];
        let completedSockets = 0;
        const filter: any = { kinds: [1], "#t": ["agora-meetup"], limit: EVENTS_PER_PAGE };
        if (until) filter.until = until;

        return new Promise((resolve, reject) => {
            const timeouts: NodeJS.Timeout[] = [];
            RELAYS.forEach((relayUrl, index) => {
                const socket = new WebSocket(relayUrl);
                const timeoutId = setTimeout(() => {
                    console.warn(`‚è±Ô∏è Timeout for ${relayUrl} during event fetch.`);
                    socket.close();
                    completedSockets++;
                    if (completedSockets === RELAYS.length) {
                        if (allEvents.length === 0) reject(new Error("All relays timed out or failed."));
                        else {
                            const uniqueEvents = Array.from(new Map(allEvents.map(e => [e.id, e])).values());
                            resolve(uniqueEvents.sort((a, b) => b.created_at - a.created_at));
                        }
                    }
                }, TIMEOUT_MS);
                timeouts.push(timeoutId);

                socket.onopen = () => {
                    clearTimeout(timeouts[index]);
                    socket.send(JSON.stringify(["REQ", `agora-feed-${Date.now()}`, filter]));
                };
                socket.onmessage = (msg) => {
                    const data = JSON.parse(msg.data);
                    if (data[0] === 'EVENT' && data[2]) allEvents.push(data[2]);
                    if (data[0] === 'EOSE') {
                        socket.close();
                        completedSockets++;
                        if (completedSockets === RELAYS.length) {
                            const uniqueEvents = Array.from(new Map(allEvents.map(e => [e.id, e])).values());
                            resolve(uniqueEvents.sort((a, b) => b.created_at - a.created_at));
                        }
                    }
                };
                socket.onerror = () => {
                    clearTimeout(timeouts[index]);
                    socket.close();
                    completedSockets++;
                    if (completedSockets === RELAYS.length) {
                        if (allEvents.length === 0) reject(new Error("All relays failed to connect."));
                        else {
                            const uniqueEvents = Array.from(new Map(allEvents.map(e => [e.id, e])).values());
                            resolve(uniqueEvents.sort((a, b) => b.created_at - a.created_at));
                        }
                    }
                };
            });
        });
    };
    
    const handleLoadMore = async () => {
        if (isLoadingMore || !hasMoreEvents) return;
        clearError();
        setIsLoadingMore(true);
        try {
            const lastEventTimestamp = events[events.length - 1]?.created_at;
            if (!lastEventTimestamp) { setHasMoreEvents(false); return; }
            const moreEvents = await fetchEventsWithTimeout(lastEventTimestamp);
            if (moreEvents.length > 0) {
                setEvents(prevEvents => [...prevEvents, ...moreEvents]);
                await processNewEvents(moreEvents);
            } else {
                setHasMoreEvents(false);
            }
        } catch (err) {
            console.error("Failed to load more events:", err);
            setError("Failed to load more events. Please try again.");
        } finally {
            setIsLoadingMore(false);
        }
    };

    const fetchCommentsForEvents = async (eventIds: string[]) => {
        const allCommentsMap = new Map<string, any>();
        const commenterPubkeys = new Set<string>();
        for (const relayUrl of RELAYS) {
            try {
                await new Promise<void>((resolve) => {
                    const socket = new WebSocket(relayUrl);
                    const timeoutId = setTimeout(() => { console.log(`‚è±Ô∏è Timeout for ${relayUrl} during comment fetch.`); socket.close(); resolve(); }, TIMEOUT_MS);
                    socket.onopen = () => { clearTimeout(timeoutId); const filters = eventIds.map(id => ({ kinds: [1], '#e': [id] })); socket.send(JSON.stringify(["REQ", "comments", ...filters])); };
                    socket.onmessage = (msg) => {
                        const data = JSON.parse(msg.data);
                        if (data[0] === 'EVENT' && data[2] && data[2].kind === 1) {
                            const comment = data[2]; const replyToId = comment.tags.find((t: any[]) => t[0] === 'e')?.[1];
                            if (replyToId) { allCommentsMap.set(comment.id, { ...comment, replyToId }); commenterPubkeys.add(comment.pubkey); }
                        }
                        if (data[0] === 'EOSE') { clearTimeout(timeoutId); socket.close(); resolve(); }
                    };
                    socket.onerror = () => { clearTimeout(timeoutId); socket.close(); resolve(); };
                });
            } catch (e) { console.warn(e); }
        }
        const allComments: { [eventId: string]: any[] } = {};
        for (const comment of allCommentsMap.values()) {
            if (!allComments[comment.replyToId]) allComments[comment.replyToId] = [];
            allComments[comment.replyToId].push(comment);
        }
        for (const eventId in allComments) allComments[eventId].sort((a, b) => a.created_at - b.created_at);
        setComments(allComments);
        fetchProfilesForPubkeys(Array.from(commenterPubkeys));
    };

    const fetchProfilesForPubkeys = async (pubkeys: string[]) => {
        const profiles: { [key: string]: any } = {};
        for (const pubkey of pubkeys) {
            for (const relayUrl of RELAYS) {
                try {
                    await new Promise<void>((resolve, reject) => {
                        const socket = new WebSocket(relayUrl);
                        const timeoutId = setTimeout(() => { console.log(`‚è±Ô∏è Timeout for ${relayUrl} during profile fetch for ${pubkey.slice(0,8)}.`); socket.close(); reject(); }, TIMEOUT_MS);
                        socket.onopen = () => { clearTimeout(timeoutId); socket.send(JSON.stringify(["REQ", `profile-${pubkey.substring(0,8)}`, { kinds: [0], authors: [pubkey], limit: 1 }])); };
                        socket.onmessage = (msg) => {
                            const data = JSON.parse(msg.data);
                            if (data[0] === 'EVENT' && data[2] && data[2].kind === 0) {
                                try { profiles[pubkey] = JSON.parse(data[2].content); clearTimeout(timeoutId); socket.close(); resolve(); }
                                catch (e) { console.warn(`Failed to parse profile for ${pubkey}`); clearTimeout(timeoutId); socket.close(); resolve(); }
                            }
                            if (data[0] === 'EOSE') { clearTimeout(timeoutId); socket.close(); resolve(); }
                        };
                        socket.onerror = () => { clearTimeout(timeoutId); socket.close(); reject(); };
                    });
                    break;
                } catch (e) { /* continue */ }
            }
        }
        setCommenterProfiles(prev => ({ ...prev, ...profiles }));
    };

    const fetchMyFriendsListWithTimeout = async () => {
        const myFollows = new Set<string>();
        for (const relayUrl of RELAYS) {
            try {
                await new Promise<void>((resolve, reject) => {
                    const socket = new WebSocket(relayUrl);
                    const timeoutId = setTimeout(() => { console.warn(`‚è±Ô∏è Timeout for ${relayUrl} during contact fetch.`); socket.close(); reject(); }, TIMEOUT_MS);
                    socket.onopen = () => { clearTimeout(timeoutId); socket.send(JSON.stringify(["REQ", "my-contacts", { kinds: [3], authors: [userPublicKey], limit: 1 }])); };
                    socket.onmessage = (msg) => {
                        const data = JSON.parse(msg.data);
                        if (data[0] === 'EVENT' && data[2] && data[2].kind === 3) { data[2].tags.forEach((tag: string[]) => { if (tag[0] === 'p') myFollows.add(tag[1]); }); clearTimeout(timeoutId); socket.close(); resolve(); }
                        if (data[0] === 'EOSE') { clearTimeout(timeoutId); socket.close(); resolve(); }
                    };
                    socket.onerror = () => { clearTimeout(timeoutId); socket.close(); reject(); };
                });
                break;
            } catch (e) { console.warn(`Could not fetch contacts from ${relayUrl}`); }
        }
        const mutualFriends = new Set<string>();
        for (const pubkey of myFollows) {
            let allRelaysFailed = true;
            for (const relayUrl of RELAYS) {
                try {
                    await new Promise<void>((resolve) => {
                        const socket = new WebSocket(relayUrl);
                        const timeoutId = setTimeout(() => { console.log(`‚è±Ô∏è Timeout for ${relayUrl} during mutual check for ${pubkey.slice(0,8)}.`); socket.close(); resolve(); }, TIMEOUT_MS);
                        socket.onopen = () => { clearTimeout(timeoutId); socket.send(JSON.stringify(["REQ", `check-${pubkey.slice(0,8)}`, { kinds: [3], authors: [pubkey], limit: 1 }])); };
                        socket.onmessage = (msg) => {
                            const data = JSON.parse(msg.data);
                            if (data[0] === 'EVENT' && data[2] && data[2].kind === 3) {
                                const theirFollows = new Set(data[2].tags.map((tag: string[]) => tag[1]));
                                if (theirFollows.has(userPublicKey)) mutualFriends.add(pubkey);
                                clearTimeout(timeoutId); socket.close(); resolve();
                            }
                            if (data[0] === 'EOSE') { clearTimeout(timeoutId); socket.close(); resolve(); }
                        };
                        socket.onerror = () => { clearTimeout(timeoutId); socket.close(); resolve(); };
                    });
                    allRelaysFailed = false; break;
                } catch (e) { /* continue */ }
            }
            if(allRelaysFailed) console.warn(`All relays failed to fetch contact list for ${pubkey.slice(0,8)}. Could not determine mutual status.`);
        }
        setFriends(mutualFriends);
    };

    const fetchRSVPsAndCancellations = async (eventIds: string[]) => {
        const allRsvps: { [eventId: string]: Set<string> } = {}; eventIds.forEach(id => allRsvps[id] = new Set());
        const userActions: { [eventId: string]: 'RSVP' | 'CANCEL' } = {};
        for (const relayUrl of RELAYS) {
            try {
                await new Promise<void>((resolve) => {
                    const socket = new WebSocket(relayUrl);
                    const timeoutId = setTimeout(() => { console.log(`‚è±Ô∏è Timeout for ${relayUrl} during RSVP fetch.`); socket.close(); resolve(); }, TIMEOUT_MS);
                    socket.onopen = () => { clearTimeout(timeoutId); const filters = eventIds.map(id => ({ kinds: [7], '#e': [id], limit: 50 })); socket.send(JSON.stringify(["REQ", "rsvps", ...filters])); };
                    socket.onmessage = (msg) => {
                        const data = JSON.parse(msg.data);
                        if (data[0] === 'EVENT' && data[2] && data[2].kind === 7) {
                            const eventId = data[2].tags.find((t: any[]) => t[0] === 'e')?.[1]; const pubkey = data[2].pubkey; const content = data[2].content;
                            if (eventId && (content === 'RSVP' || content === 'CANCEL')) {
                                if (pubkey === userPublicKey) userActions[eventId] = content as 'RSVP' | 'CANCEL';
                                if (content === 'RSVP') allRsvps[eventId].add(pubkey);
                            }
                        }
                        if (data[0] === 'EOSE') { clearTimeout(timeoutId); socket.close(); resolve(); }
                    };
                    socket.onerror = () => { clearTimeout(timeoutId); socket.close(); resolve(); };
                });
            } catch (e) { console.warn(e); }
        }
        for (const eventId in userActions) if (userActions[eventId] === 'CANCEL') allRsvps[eventId].delete(userPublicKey);
        setRsvps(prevRsvps => ({ ...prevRsvps, ...allRsvps }));
    };

    const fetchProfilesFromRelaysWithTimeout = async (eventsToFetch: any[]) => {
        const hostPubkeys = [...new Set(eventsToFetch.map(e => e.pubkey))]; const profiles: { [key: string]: any } = {};
        for (const pubkey of hostPubkeys) {
            let profileFound = false;
            for (const relayUrl of RELAYS) {
                if (profileFound) break;
                try {
                    await new Promise<void>((resolve) => {
                        const socket = new WebSocket(relayUrl);
                        const timeoutId = setTimeout(() => { console.log(`‚è±Ô∏è Timeout for ${relayUrl} during profile fetch for ${pubkey.slice(0,8)}.`); socket.close(); resolve(); }, TIMEOUT_MS);
                        socket.onopen = () => { clearTimeout(timeoutId); socket.send(JSON.stringify(["REQ", `profile-${pubkey.substring(0,8)}`, { kinds: [0], authors: [pubkey], limit: 1 }])); };
                        socket.onmessage = (msg) => {
                            const data = JSON.parse(msg.data);
                            if (data[0] === 'EVENT' && data[2] && data[2].kind === 0) {
                                try { profiles[pubkey] = JSON.parse(data[2].content); profileFound = true; clearTimeout(timeoutId); socket.close(); resolve(); }
                                catch (e) { console.warn(`Failed to parse profile for ${pubkey}`); clearTimeout(timeoutId); socket.close(); resolve(); }
                            }
                            if (data[0] === 'EOSE') { clearTimeout(timeoutId); socket.close(); resolve(); }
                        };
                        socket.onerror = () => { clearTimeout(timeoutId); socket.close(); resolve(); };
                    });
                } catch (e) { /* continue */ }
            }
        }
        setHostProfiles(prev => ({ ...prev, ...profiles }));
    };

    // --- Event Handlers ---

    const handleCreateEvent = async (e: React.FormEvent, newEvent: { name: string, location: string, startTime: string, description: string, image_url: string, landingPageUrl: string }) => {
        e.preventDefault();
        const storedPrivateKey = localStorage.getItem('agora_privateKey'); let signedEvent;
        if (storedPrivateKey) {
            signedEvent = nostrTools.finalizeEvent({
                created_at: Math.floor(Date.now() / 1000), kind: 1, tags: [["t", "agora-meetup"]], content: JSON.stringify(newEvent),
            }, nostrTools.utils.hexToBytes(storedPrivateKey)); // FIX: Convert hex key to bytes
        }
        else if (window.nostr) {
            signedEvent = await window.nostr.signEvent({ created_at: Math.floor(Date.now() / 1000), kind: 1, tags: [["t", "agora-meetup"]], content: JSON.stringify(newEvent), });
        }
        else { alert('No signing method available. Please log in again.'); return; }
        for (const relayUrl of RELAYS) { try { await new Promise<void>((resolve, reject) => { const socket = new WebSocket(relayUrl); socket.onopen = () => { socket.send(JSON.stringify(["EVENT", signedEvent])); setTimeout(() => { socket.close(); resolve(); }, 500); }; socket.onerror = reject; }); } catch (err) { console.warn(`Failed to post to ${relayUrl}`); } }
        window.location.reload();
    };

    const handleToggleRSVP = async (eventId: string) => {
        const currentRsvps = rsvps[eventId] || new Set(); const isCurrentlyAttending = currentRsvps.has(userPublicKey); const action = isCurrentlyAttending ? 'CANCEL' : 'RSVP';
        const storedPrivateKey = localStorage.getItem('agora_privateKey'); let signedEvent;
        if (storedPrivateKey) {
            signedEvent = nostrTools.finalizeEvent({
                created_at: Math.floor(Date.now() / 1000), kind: 7, tags: [['e', eventId], ['p', userPublicKey]], content: action
            }, nostrTools.utils.hexToBytes(storedPrivateKey)); // FIX: Convert hex key to bytes
        }
        else if (window.nostr) {
            signedEvent = await window.nostr.signEvent({ created_at: Math.floor(Date.now() / 1000), kind: 7, tags: [['e', eventId], ['p', userPublicKey]], content: action });
        }
        else { alert('Cannot sign action.'); return; }
        for (const relayUrl of RELAYS) { try { await new Promise<void>((resolve) => { const socket = new WebSocket(relayUrl); socket.onopen = () => { socket.send(JSON.stringify(["EVENT", signedEvent])); setTimeout(() => { socket.close(); resolve(); }, 500); }; socket.onerror = () => { socket.close(); resolve(); }; }); } catch (e) { console.warn(e); } }
        setRsvps(prevRsvps => { const newRsvps = { ...prevRsvps }; const eventRsvps = new Set(newRsvps[eventId]); if (action === 'RSVP') eventRsvps.add(userPublicKey); else eventRsvps.delete(userPublicKey); newRsvps[eventId] = eventRsvps; return newRsvps; });
    };

    const handlePostComment = async (eventId: string, finalContent: string) => {
        if (!finalContent || !finalContent.trim()) return;
        const storedPrivateKey = localStorage.getItem('agora_privateKey'); let signedEvent;
        if (storedPrivateKey) {
            signedEvent = nostrTools.finalizeEvent({
                created_at: Math.floor(Date.now() / 1000), kind: 1, tags: [['e', eventId], ['p', userPublicKey]], content: finalContent
            }, nostrTools.utils.hexToBytes(storedPrivateKey)); // FIX: Convert hex key to bytes
        }
        else if (window.nostr) {
            signedEvent = await window.nostr.signEvent({ created_at: Math.floor(Date.now() / 1000), kind: 1, tags: [['e', eventId], ['p', userPublicKey]], content: finalContent });
        }
        else { alert('Cannot sign action.'); return; }
        for (const relayUrl of RELAYS) { try { await new Promise<void>((resolve) => { const socket = new WebSocket(relayUrl); socket.onopen = () => { socket.send(JSON.stringify(["EVENT", signedEvent])); setTimeout(() => { socket.close(); resolve(); }, 500); }; socket.onerror = () => { socket.close(); resolve(); }; }); } catch (e) { console.warn(e); } }
        window.location.reload();
    };
    
    const handleShareAsNote = async (event: any) => {
        const eventData = JSON.parse(event.content); 
        const startTime = DateTime.fromISO(eventData.startTime);

        let noteContent = `üóìÔ∏è EVENT: ${eventData.name}
üìç WHERE: ${eventData.location}
üïñ WHEN: ${startTime.toLocaleString(DateTime.DATETIME_FULL)}
üìù DETAILS: ${eventData.description}`;

        if (eventData.image_url && eventData.image_url.trim()) {
            noteContent += `\n\n${eventData.image_url.trim()}`;
        }

        noteContent += `\n\n---
Posted with the Agora Marketplace App. A decentralized platform for local events.
Learn more and contribute on GitHub: https://github.com/Neopatriarch/AgoraMarketplace`;

        const storedPrivateKey = localStorage.getItem('agora_privateKey'); let signedEvent;
        if (storedPrivateKey) {
            signedEvent = nostrTools.finalizeEvent({
                created_at: Math.floor(Date.now() / 1000), kind: 1, tags: [], content: noteContent,
            }, nostrTools.utils.hexToBytes(storedPrivateKey)); // FIX: Convert hex key to bytes
        }
        else if (window.nostr) {
            signedEvent = await window.nostr.signEvent({ created_at: Math.floor(Date.now() / 1000), kind: 1, tags: [], content: noteContent, });
        }
        else { alert('No signing method available. Please log in again.'); return; }
        for (const relayUrl of RELAYS) { try { await new Promise<void>((resolve, reject) => { const socket = new WebSocket(relayUrl); socket.onopen = () => { socket.send(JSON.stringify(["EVENT", signedEvent])); setTimeout(() => { socket.close(); resolve(); }, 500); }; socket.onerror = reject; }); } catch (err) { console.warn(`Failed to post note to ${relayUrl}`); } }
        alert('Event shared as a public note!');
    };

    const handleShareEvent = async (event: any) => {
        const eventData = JSON.parse(event.content); 
        const startTime = DateTime.fromISO(eventData.startTime);
        
        const shareUrl = `https://github.com/Neopatriarch/AgoraMarketplace`;

        const textToCopy = `üóìÔ∏è ${eventData.name}

üìç ${eventData.location}
üïñ ${startTime.toLocaleString(DateTime.DATETIME_FULL)}

üìù
${eventData.description}

---
View this event and more on the Agora Marketplace:
${shareUrl}`;

        if (navigator.share) {
            try {
                const shareText = `üóìÔ∏è ${eventData.name}\nüìç ${eventData.location}\nüïñ ${startTime.toLocaleString(DateTime.DATETIME_FULL)}\n\n${eventData.description}`;
                await navigator.share({ title: eventData.name, text: shareText, url: shareUrl });
                return;
            } catch (err) {
                console.error('Web Share failed or was cancelled:', err);
            }
        }

        if (navigator.clipboard && window.isSecureContext) {
            try {
                await navigator.clipboard.writeText(textToCopy);
                alert('Event details copied to clipboard! You can now paste them anywhere.');
                return;
            } catch (err) {
                console.error('Clipboard API failed:', err);
            }
        }

        const textArea = document.createElement('textarea');
        textArea.value = textToCopy;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
            document.execCommand('copy');
            alert('Event details copied to clipboard! You can now paste them anywhere.');
        } catch (err) {
            console.error('Fallback copy failed:', err);
            alert('Sorry, your browser does not support direct sharing or copying to clipboard. You will have to copy the text manually.');
        } finally {
            document.body.removeChild(textArea);
        }
    };

    // --- Initial Data Load ---
    useEffect(() => {
        const fetchInitialData = async () => { clearError(); setIsLoading(true); try { fetchMyFriendsListWithTimeout(); const initialEvents = await fetchEventsWithTimeout(); setEvents(initialEvents); await processNewEvents(initialEvents); } catch (err) { console.error("Failed to load initial data:", err); setError("Failed to load events. Please check your connection and try again."); } finally { setIsLoading(false); } };
        fetchInitialData();
    }, []);

    // --- Return all necessary state and handlers ---
    return {
        events, hostProfiles, commenterProfiles, friends, rsvps, comments, isLoading, isLoadingMore, hasMoreEvents, error,
        clearError, handleLoadMore, handleCreateEvent, handleToggleRSVP, handlePostComment, handleShareAsNote, handleShareEvent,
    };
};

// --- End of File ---
// Filepath: src/hooks/useAgoraData.ts
// Version: v1.0.10
