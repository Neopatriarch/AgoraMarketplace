// Filepath: src/HomePage.tsx
// Author: Robert Kirkpatrick
// Generated by: Venice AI
// v15.1.0 - Clean, fully formatted baseline. Added image embedding to comments.

import React, { useState, useEffect } from 'react';
import { DateTime } from 'luxon';
import * as nostrTools from 'nostr-tools';

// --- Main HomePage Component ---
// This component is the core of the Agora application. It fetches, displays, and manages
// all interactions for events, including RSVPs and comments, by communicating with Nostr relays.
const HomePage: React.FC<{ userPublicKey: string }> = ({ userPublicKey }) => {
    // --- State Management ---
    // Stores the list of all fetched and displayed events.
    const [events, setEvents] = useState<any[]>([]);
    // Stores fetched user profiles (kind: 0) for event hosts, keyed by pubkey.
    const [hostProfiles, setHostProfiles] = useState<{ [key: string]: any }>({});
    // Stores fetched user profiles for commenters, keyed by pubkey.
    const [commenterProfiles, setCommenterProfiles] = useState<{ [key: string]: any }>({});
    // A Set of pubkeys representing mutual friends (bi-directional follows).
    const [friends, setFriends] = useState<Set<string>>(new Set());
    // Stores RSVPs for each event, keyed by event ID, with a Set of attending pubkeys as the value.
    const [rsvps, setRsvps] = useState<{ [eventId: string]: Set<string> }>({});
    // Stores comments for each event, keyed by event ID, with an array of comment events as the value.
    const [comments, setComments] = useState<{ [eventId: string]: any[] }>({});
    // Loading state for the initial data fetch.
    const [isLoading, setIsLoading] = useState(true);
    // Loading state for the "Load More" pagination button.
    const [isLoadingMore, setIsLoadingMore] = useState(false);
    // Flag to determine if more events are available to be paginated.
    const [hasMoreEvents, setHasMoreEvents] = useState(true);
    // State to control the visibility of the "Create New Event" form.
    const [showCreateForm, setShowCreateForm] = useState(false);
    // State object to manage the input fields of the new event creation form.
    const [newEvent, setNewEvent] = useState({ name: '', location: '', startTime: '', description: '', image_url: '' });
    // State to manage the text input for each event's comment section, keyed by event ID.
    const [commentText, setCommentText] = useState<{ [eventId: string]: string }>({});
    // State to manage the image URL input for each event's comment section.
    const [commentImageUrl, setCommentImageUrl] = useState<{ [eventId: string]: string }>({});
    // State to control the visibility of the image URL input for each event.
    const [showCommentImageInput, setShowCommentImageInput] = useState<{ [eventId: string]: boolean }>({});

    // --- Constants ---
    // List of Nostr relays to connect with. Using multiple relays provides resilience.
    const RELAYS = ['wss://relay.damus.io', 'wss://nos.lol', 'wss://relay.snort.social'];
    // Number of events to fetch per page for pagination.
    const EVENTS_PER_PAGE = 10;

    // --- Data Fetching & Processing ---

    /**
     * Fetches all related data (profiles, RSVPs, comments) for a given list of events.
     * This function is called both after the initial load and after loading more events.
     * @param newEvents The array of event objects to process.
     */
    const processNewEvents = async (newEvents: any[]) => {
        if (newEvents.length === 0) {
            // If no events were returned, we can assume there are no more to load.
            setHasMoreEvents(false);
            return;
        }

        const eventIds = newEvents.map(e => e.id);

        // Fetch all related data in parallel for efficiency.
        await Promise.all([
            fetchProfilesFromRelaysWithTimeout(newEvents),
            fetchRSVPsAndCancellations(eventIds),
            fetchCommentsForEvents(eventIds)
        ]);
    };

    /**
     * Main orchestrator for the initial data load on component mount.
     * It fetches the first page of events and all their associated data.
     */
    useEffect(() => {
        const fetchInitialData = async () => {
            setIsLoading(true);
            try {
                // Fetch the user's friend list first, as it's independent of events.
                fetchMyFriendsListWithTimeout();

                // Fetch the initial page of events.
                const initialEvents = await fetchEventsWithTimeout();
                setEvents(initialEvents);

                // Process these events to get their associated profiles, RSVPs, etc.
                await processNewEvents(initialEvents);

                // If we got fewer events than the limit, we know there are no more pages.
                if (initialEvents.length < EVENTS_PER_PAGE) {
                    setHasMoreEvents(false);
                }

            } catch (error) {
                console.error("Failed to load initial data:", error);
            } finally {
                setIsLoading(false);
            }
        };
        fetchInitialData();
    }, []); // Runs only once on mount

    /**
     * Fetches events from Nostr relays with a mandatory timeout.
     * @param until Optional timestamp to paginate and fetch events older than this time.
     * @returns A promise that resolves to a sorted, de-duplicated array of event objects.
     */
    const fetchEventsWithTimeout = async (until?: number): Promise<any[]> => {
        const allEvents: any[] = [];
        let completedSockets = 0;
        const TIMEOUT_MS = 5000; // 5-second timeout for each relay.

        const filter: any = { kinds: [1], "#t": ["agora-meetup"], limit: EVENTS_PER_PAGE };
        if (until) {
            // If `until` is provided, add it to the filter to get the previous page of events.
            filter.until = until;
        }

        return new Promise(resolve => {
            const timeouts: NodeJS.Timeout[] = [];
            RELAYS.forEach((relayUrl, index) => {
                const socket = new WebSocket(relayUrl);
                const timeoutId = setTimeout(() => {
                    console.warn(`‚è±Ô∏è Timeout for ${relayUrl} during event fetch.`);
                    socket.close();
                    completedSockets++;
                    if (completedSockets === RELAYS.length) {
                        const uniqueEvents = Array.from(new Map(allEvents.map(e => [e.id, e])).values());
                        const sortedEvents = uniqueEvents.sort((a, b) => b.created_at - a.created_at);
                        resolve(sortedEvents);
                    }
                }, TIMEOUT_MS);
                timeouts.push(timeoutId);

                socket.onopen = () => {
                    clearTimeout(timeouts[index]);
                    const subscription = JSON.stringify(["REQ", `agora-feed-${Date.now()}`, filter]);
                    socket.send(subscription);
                };

                socket.onmessage = (msg) => {
                    const data = JSON.parse(msg.data);
                    if (data[0] === 'EVENT' && data[2]) allEvents.push(data[2]);
                    if (data[0] === 'EOSE') {
                        socket.close();
                        completedSockets++;
                        if (completedSockets === RELAYS.length) {
                            const uniqueEvents = Array.from(new Map(allEvents.map(e => [e.id, e])).values());
                            const sortedEvents = uniqueEvents.sort((a, b) => b.created_at - a.created_at);
                            resolve(sortedEvents);
                        }
                    }
                };

                socket.onerror = () => {
                    clearTimeout(timeouts[index]);
                    socket.close();
                    completedSockets++;
                    if (completedSockets === RELAYS.length) {
                        const uniqueEvents = Array.from(new Map(allEvents.map(e => [e.id, e])).values());
                        const sortedEvents = uniqueEvents.sort((a, b) => b.created_at - a.created_at);
                        resolve(sortedEvents);
                    }
                };
            });
        });
    };
    
    /**
     * Handles the "Load More" button click.
     * Fetches the next page of events and appends them to the existing list.
     */
    const handleLoadMore = async () => {
        if (isLoadingMore || !hasMoreEvents) return;
        setIsLoadingMore(true);

        try {
            // Get the timestamp of the last event in the current list to use as the `until` parameter.
            const lastEventTimestamp = events[events.length - 1]?.created_at;
            if (!lastEventTimestamp) {
                setHasMoreEvents(false);
                return;
            }

            const moreEvents = await fetchEventsWithTimeout(lastEventTimestamp);

            if (moreEvents.length > 0) {
                // Append new events to the existing list using immutable state update.
                setEvents(prevEvents => [...prevEvents, ...moreEvents]);
                
                // Process the new events to get their data.
                await processNewEvents(moreEvents);

                // If we got fewer events than the limit, we're at the end of the feed.
                if (moreEvents.length < EVENTS_PER_PAGE) {
                    setHasMoreEvents(false);
                }
            } else {
                // No more events were found.
                setHasMoreEvents(false);
            }
        } catch (error) {
            console.error("Failed to load more events:", error);
        } finally {
            setIsLoadingMore(false);
        }
    };

    /**
     * Fetches comments (kind: 1 replies) for a given list of event IDs from multiple relays.
     * Uses a Map to de-duplicate comments received from different relays.
     * @param eventIds An array of event IDs to fetch comments for.
     */
    const fetchCommentsForEvents = async (eventIds: string[]) => {
        const allCommentsMap = new Map<string, any>(); // Use Map for de-duplication by comment ID.
        const commenterPubkeys = new Set<string>();
        const TIMEOUT_MS = 5000;

        for (const relayUrl of RELAYS) {
            try {
                await new Promise<void>((resolve) => {
                    const socket = new WebSocket(relayUrl);
                    const timeoutId = setTimeout(() => { 
                        console.warn(`‚è±Ô∏è Timeout for ${relayUrl} during comment fetch.`); 
                        socket.close(); 
                        resolve(); 
                    }, TIMEOUT_MS);
                    
                    socket.onopen = () => { 
                        clearTimeout(timeoutId); 
                        const subId = "comments"; 
                        const filters = eventIds.map(id => ({ kinds: [1], '#e': [id] })); 
                        socket.send(JSON.stringify(["REQ", subId, ...filters])); 
                    };
                    
                    socket.onmessage = (msg) => {
                        const data = JSON.parse(msg.data);
                        if (data[0] === 'EVENT' && data[2] && data[2].kind === 1) {
                            const comment = data[2]; 
                            const replyToId = comment.tags.find(t => t[0] === 'e')?.[1];
                            if (replyToId) {
                                // Store the comment with its unique ID as the key to prevent duplicates.
                                allCommentsMap.set(comment.id, { ...comment, replyToId });
                                commenterPubkeys.add(comment.pubkey);
                            }
                        }
                        if (data[0] === 'EOSE') { 
                            clearTimeout(timeoutId); 
                            socket.close(); 
                            resolve(); 
                        }
                    };
                    
                    socket.onerror = () => { 
                        clearTimeout(timeoutId); 
                        socket.close(); 
                        resolve(); 
                    };
                });
            } catch (e) { 
                console.warn(e); 
            }
        }
        
        // Convert the Map back to the desired object structure for state.
        const allComments: { [eventId: string]: any[] } = {};
        for (const comment of allCommentsMap.values()) {
            if (!allComments[comment.replyToId]) {
                allComments[comment.replyToId] = [];
            }
            allComments[comment.replyToId].push(comment);
        }

        // Sort comments by creation date for each event.
        for (const eventId in allComments) {
            allComments[eventId].sort((a, b) => a.created_at - b.created_at);
        }
        
        setComments(allComments);
        // Fetch profiles for all unique commenters found.
        fetchProfilesForPubkeys(Array.from(commenterPubkeys));
    };

    /**
     * Fetches user metadata (kind: 0) for a specific list of pubkeys.
     * @param pubkeys An array of public keys to fetch profiles for.
     */
    const fetchProfilesForPubkeys = async (pubkeys: string[]) => {
        const profiles: { [key: string]: any } = {};
        const TIMEOUT_MS = 5000;

        for (const pubkey of pubkeys) {
            for (const relayUrl of RELAYS) {
                try {
                    await new Promise<void>((resolve, reject) => {
                        const socket = new WebSocket(relayUrl);
                        const timeoutId = setTimeout(() => { 
                            console.warn(`‚è±Ô∏è Timeout for ${relayUrl} during profile fetch for ${pubkey.slice(0,8)}.`); 
                            socket.close(); 
                            reject(); 
                        }, TIMEOUT_MS);
                        
                        socket.onopen = () => { 
                            clearTimeout(timeoutId); 
                            const subId = `profile-${pubkey.substring(0,8)}`; 
                            const subscription = JSON.stringify(["REQ", subId, { kinds: [0], authors: [pubkey], limit: 1 }]); 
                            socket.send(subscription); 
                        };
                        
                        socket.onmessage = (msg) => {
                            const data = JSON.parse(msg.data);
                            if (data[0] === 'EVENT' && data[2] && data[2].kind === 0) {
                                try { 
                                    profiles[pubkey] = JSON.parse(data[2].content); 
                                    clearTimeout(timeoutId); 
                                    socket.close(); 
                                    resolve(); 
                                } catch (e) { 
                                    console.warn(`Failed to parse profile for ${pubkey}`); 
                                    clearTimeout(timeoutId); 
                                    socket.close(); 
                                    resolve(); 
                                }
                            }
                            if (data[0] === 'EOSE') { 
                                clearTimeout(timeoutId); 
                                socket.close(); 
                                resolve(); 
                            }
                        };
                        
                        socket.onerror = () => { 
                            clearTimeout(timeoutId); 
                            socket.close(); 
                            reject(); 
                        };
                    });
                    break; // Stop trying other relays once a profile is found.
                } catch (e) { 
                    /* continue to next relay */ 
                }
            }
        }
        setCommenterProfiles(prev => ({ ...prev, ...profiles }));
    };

    /**
     * Fetches the user's contact list (kind: 3) and determines mutual friends.
     * A mutual friend is someone you follow who also follows you back.
     */
    const fetchMyFriendsListWithTimeout = async () => {
        const myFollows = new Set<string>();
        const TIMEOUT_MS = 5000;
        
        // First, get the list of people the user follows.
        for (const relayUrl of RELAYS) {
            try {
                await new Promise<void>((resolve, reject) => {
                    const socket = new WebSocket(relayUrl);
                    const timeoutId = setTimeout(() => { 
                        console.warn(`‚è±Ô∏è Timeout for ${relayUrl} during contact fetch.`); 
                        socket.close(); 
                        reject(); 
                    }, TIMEOUT_MS);
                    
                    socket.onopen = () => { 
                        clearTimeout(timeoutId); 
                        socket.send(JSON.stringify(["REQ", "my-contacts", { kinds: [3], authors: [userPublicKey], limit: 1 }])); 
                    };
                    
                    socket.onmessage = (msg) => {
                        const data = JSON.parse(msg.data);
                        if (data[0] === 'EVENT' && data[2] && data[2].kind === 3) { 
                            data[2].tags.forEach((tag: string[]) => { 
                                if (tag[0] === 'p') myFollows.add(tag[1]); 
                            }); 
                            clearTimeout(timeoutId); 
                            socket.close(); 
                            resolve(); 
                        }
                        if (data[0] === 'EOSE') { 
                            clearTimeout(timeoutId); 
                            socket.close(); 
                            resolve(); 
                        }
                    };
                    
                    socket.onerror = () => { 
                        clearTimeout(timeoutId); 
                        socket.close(); 
                        reject(); 
                    };
                });
                break;
            } catch (e) { 
                console.warn(`Could not fetch contacts from ${relayUrl}`); 
            }
        }
        
        // Now, for each person you follow, check if they also follow you back.
        const mutualFriends = new Set<string>();
        for (const pubkey of myFollows) {
            for (const relayUrl of RELAYS) {
                try {
                    await new Promise<void>((resolve, reject) => {
                        const socket = new WebSocket(relayUrl);
                        const timeoutId = setTimeout(() => { 
                            console.warn(`‚è±Ô∏è Timeout for ${relayUrl} during mutual check for ${pubkey.slice(0,8)}.`); 
                            socket.close(); 
                            resolve(); 
                        }, TIMEOUT_MS);
                        
                        socket.onopen = () => { 
                            clearTimeout(timeoutId); 
                            socket.send(JSON.stringify(["REQ", `check-${pubkey.slice(0,8)}`, { kinds: [3], authors: [pubkey], limit: 1 }])); 
                        };
                        
                        socket.onmessage = (msg) => {
                            const data = JSON.parse(msg.data);
                            if (data[0] === 'EVENT' && data[2] && data[2].kind === 3) { 
                                const theirFollows = new Set(data[2].tags.map((tag: string[]) => tag[1])); 
                                if (theirFollows.has(userPublicKey)) { 
                                    mutualFriends.add(pubkey); 
                                } 
                                clearTimeout(timeoutId); 
                                socket.close(); 
                                resolve(); 
                            }
                            if (data[0] === 'EOSE') { 
                                clearTimeout(timeoutId); 
                                socket.close(); 
                                resolve(); 
                            }
                        };
                        
                        socket.onerror = () => { 
                            clearTimeout(timeoutId); 
                            socket.close(); 
                            resolve(); 
                        };
                    });
                    break;
                } catch (e) { 
                    /* continue */ 
                }
            }
        }
        setFriends(mutualFriends);
    };

    /**
     * Fetches RSVPs (kind: 7 reactions) and cancellations for a list of events.
     * It processes both "RSVP" and "CANCEL" reactions to determine the final attendee list.
     * @param eventIds An array of event IDs to fetch RSVPs for.
     */
    const fetchRSVPsAndCancellations = async (eventIds: string[]) => {
        const allRsvps: { [eventId: string]: Set<string> } = {};
        eventIds.forEach(id => allRsvps[id] = new Set());
        const userActions: { [eventId: string]: 'RSVP' | 'CANCEL' } = {};
        const TIMEOUT_MS = 5000;

        for (const relayUrl of RELAYS) {
            try {
                await new Promise<void>((resolve) => {
                    const socket = new WebSocket(relayUrl);
                    const timeoutId = setTimeout(() => { 
                        console.warn(`‚è±Ô∏è Timeout for ${relayUrl} during RSVP fetch.`); 
                        socket.close(); 
                        resolve(); 
                    }, TIMEOUT_MS);
                    
                    socket.onopen = () => { 
                        clearTimeout(timeoutId); 
                        const subId = "rsvps"; 
                        const filters = eventIds.map(id => ({ kinds: [7], '#e': [id], limit: 50 })); 
                        socket.send(JSON.stringify(["REQ", subId, ...filters])); 
                    };
                    
                    socket.onmessage = (msg) => {
                        const data = JSON.parse(msg.data);
                        if (data[0] === 'EVENT' && data[2] && data[2].kind === 7) {
                            // Using kind: 7 for reactions as per NIP-25.
                            const eventId = data[2].tags.find(t => t[0] === 'e')?.[1]; 
                            const pubkey = data[2].pubkey; 
                            const content = data[2].content;
                            if (eventId && (content === 'RSVP' || content === 'CANCEL')) {
                                if (pubkey === userPublicKey) { 
                                    userActions[eventId] = content as 'RSVP' | 'CANCEL'; 
                                }
                                if (content === 'RSVP') { 
                                    allRsvps[eventId].add(pubkey); 
                                }
                            }
                        }
                        if (data[0] === 'EOSE') { 
                            clearTimeout(timeoutId); 
                            socket.close(); 
                            resolve(); 
                        }
                    };
                    
                    socket.onerror = () => { 
                        clearTimeout(timeoutId); 
                        socket.close(); 
                        resolve(); 
                    };
                });
            } catch (e) { 
                console.warn(e); 
            }
        }
        
        // Apply user's latest CANCEL actions to the RSVP set.
        for (const eventId in userActions) { 
            if (userActions[eventId] === 'CANCEL') { 
                allRsvps[eventId].delete(userPublicKey); 
            } 
        }
        
        setRsvps(prevRsvps => ({ ...prevRsvps, ...allRsvps }));
    };

    /**
     * Fetches profiles (kind: 0) for the hosts of the provided events.
     * @param eventsToFetch An array of event objects to get host pubkeys from.
     */
    const fetchProfilesFromRelaysWithTimeout = async (eventsToFetch: any[]) => {
        const hostPubkeys = [...new Set(eventsToFetch.map(e => e.pubkey))];
        const profiles: { [key: string]: any } = {};
        const TIMEOUT_MS = 5000;

        for (const pubkey of hostPubkeys) {
            let profileFound = false;
            for (const relayUrl of RELAYS) {
                if (profileFound) break;
                try {
                    await new Promise<void>((resolve) => {
                        const socket = new WebSocket(relayUrl);
                        const timeoutId = setTimeout(() => { 
                            console.warn(`‚è±Ô∏è Timeout for ${relayUrl} during profile fetch for ${pubkey.slice(0,8)}.`); 
                            socket.close(); 
                            resolve(); 
                        }, TIMEOUT_MS);
                        
                        socket.onopen = () => { 
                            clearTimeout(timeoutId); 
                            const subId = `profile-${pubkey.substring(0,8)}`; 
                            const subscription = JSON.stringify(["REQ", subId, { kinds: [0], authors: [pubkey], limit: 1 }]); 
                            socket.send(subscription); 
                        };
                        
                        socket.onmessage = (msg) => {
                            const data = JSON.parse(msg.data);
                            if (data[0] === 'EVENT' && data[2] && data[2].kind === 0) {
                                try { 
                                    profiles[pubkey] = JSON.parse(data[2].content); 
                                    profileFound = true; 
                                    clearTimeout(timeoutId); 
                                    socket.close(); 
                                    resolve(); 
                                } catch (e) { 
                                    console.warn(`Failed to parse profile for ${pubkey}`); 
                                    clearTimeout(timeoutId); 
                                    socket.close(); 
                                    resolve(); 
                                }
                            }
                            if (data[0] === 'EOSE') { 
                                clearTimeout(timeoutId); 
                                socket.close(); 
                                resolve(); 
                            }
                        };
                        
                        socket.onerror = () => { 
                            clearTimeout(timeoutId); 
                            socket.close(); 
                            resolve(); 
                        };
                    });
                } catch (e) { 
                    /* continue */ 
                }
            }
        }
        setHostProfiles(prev => ({ ...prev, ...profiles }));
    };

    // --- Event Handlers ---

    /**
     * Handles the creation of a new event.
     * It constructs a kind: 1 event, signs it, and publishes it to all relays.
     * @param e The form submission event.
     */
    const handleCreateEvent = async (e: React.FormEvent) => {
        e.preventDefault();
        const storedPrivateKey = localStorage.getItem('agora_privateKey');
        let signedEvent;

        if (storedPrivateKey) {
            const eventPayload = { 
                pubkey: userPublicKey, 
                created_at: Math.floor(Date.now() / 1000), 
                kind: 1, 
                tags: [["t", "agora-meetup"]], 
                content: JSON.stringify(newEvent), 
            };
            signedEvent = nostrTools.finalizeEvent(eventPayload, storedPrivateKey);
        } else if (window.nostr) {
            const eventPayload = { 
                created_at: Math.floor(Date.now() / 1000), 
                kind: 1, 
                tags: [["t", "agora-meetup"]], 
                content: JSON.stringify(newEvent), 
            };
            signedEvent = await window.nostr.signEvent(eventPayload);
        } else { 
            alert('No signing method available. Please log in again.'); 
            return; 
        }

        for (const relayUrl of RELAYS) { 
            try { 
                await new Promise<void>((resolve, reject) => { 
                    const socket = new WebSocket(relayUrl); 
                    socket.onopen = () => { 
                        socket.send(JSON.stringify(["EVENT", signedEvent])); 
                        setTimeout(() => { 
                            socket.close(); 
                            resolve(); 
                        }, 500); 
                    }; 
                    socket.onerror = reject; 
                }); 
            } catch (err) { 
                console.warn(`Failed to post to ${relayUrl}`); 
            } 
        }

        setShowCreateForm(false); 
        setNewEvent({ name: '', location: '', startTime: '', description: '', image_url: '' }); 
        
        // A full page reload is used here for simplicity to ensure the new event appears correctly.
        window.location.reload();
    };

    /**
     * Handles toggling an RSVP for an event.
     * Posts a kind: 7 reaction with content "RSVP" or "CANCEL".
     * The UI is updated optimistically for instant feedback.
     * @param eventId The ID of the event to RSVP to.
     */
    const handleToggleRSVP = async (eventId: string) => {
        const currentRsvps = rsvps[eventId] || new Set(); 
        const isCurrentlyAttending = currentRsvps.has(userPublicKey); 
        const action = isCurrentlyAttending ? 'CANCEL' : 'RSVP';
        const storedPrivateKey = localStorage.getItem('agora_privateKey'); 
        let signedEvent;

        if (storedPrivateKey) { 
            signedEvent = nostrTools.finalizeEvent({ 
                pubkey: userPublicKey, 
                created_at: Math.floor(Date.now() / 1000), 
                kind: 7, 
                tags: [['e', eventId], ['p', userPublicKey]], 
                content: action 
            }, storedPrivateKey); 
        }
        else if (window.nostr) { 
            signedEvent = await window.nostr.signEvent({ 
                created_at: Math.floor(Date.now() / 1000), 
                kind: 7, 
                tags: [['e', eventId], ['p', userPublicKey]], 
                content: action 
            }); 
        }
        else { 
            alert('Cannot sign action.'); 
            return; 
        }

        for (const relayUrl of RELAYS) { 
            try { 
                await new Promise<void>((resolve) => { 
                    const socket = new WebSocket(relayUrl); 
                    socket.onopen = () => { 
                        socket.send(JSON.stringify(["EVENT", signedEvent])); 
                        setTimeout(() => { 
                            socket.close(); 
                            resolve(); 
                        }, 500); 
                    }; 
                    socket.onerror = () => { 
                        socket.close(); 
                        resolve(); 
                    }; 
                }); 
            } catch (e) { 
                console.warn(e); 
            } 
        }

        // Optimistic UI update: update state immediately, then communicate with relays.
        setRsvps(prevRsvps => { 
            const newRsvps = { ...prevRsvps }; 
            const eventRsvps = new Set(newRsvps[eventId]); 
            if (action === 'RSVP') { 
                eventRsvps.add(userPublicKey); 
            } else { 
                eventRsvps.delete(userPublicKey); 
            } 
            newRsvps[eventId] = eventRsvps; 
            return newRsvps; 
        });
    };

    /**
     * Handles posting a new comment to an event.
     * Creates a kind: 1 reply event and publishes it.
     * @param eventId The ID of the event to comment on.
     */
    const handlePostComment = async (eventId: string) => {
        const text = commentText[eventId]; 
        const imageUrl = commentImageUrl[eventId];

        if (!text || !text.trim()) return;
        
        // Combine text and image URL into the final content string.
        let finalContent = text.trim();
        if (imageUrl && imageUrl.trim()) {
            finalContent += `\n\n${imageUrl.trim()}`;
        }

        const storedPrivateKey = localStorage.getItem('agora_privateKey'); 
        let signedEvent;

        if (storedPrivateKey) { 
            signedEvent = nostrTools.finalizeEvent({ 
                pubkey: userPublicKey, 
                created_at: Math.floor(Date.now() / 1000), 
                kind: 1, 
                tags: [['e', eventId], ['p', userPublicKey]], 
                content: finalContent 
            }, storedPrivateKey); 
        }
        else if (window.nostr) { 
            signedEvent = await window.nostr.signEvent({ 
                created_at: Math.floor(Date.now() / 1000), 
                kind: 1, 
                tags: [['e', eventId], ['p', userPublicKey]], 
                content: finalContent 
            }); 
        }
        else { 
            alert('Cannot sign action.'); 
            return; 
        }

        for (const relayUrl of RELAYS) { 
            try { 
                await new Promise<void>((resolve) => { 
                    const socket = new WebSocket(relayUrl); 
                    socket.onopen = () => { 
                        socket.send(JSON.stringify(["EVENT", signedEvent])); 
                        setTimeout(() => { 
                            socket.close(); 
                            resolve(); 
                        }, 500); 
                    }; 
                    socket.onerror = () => { 
                        socket.close(); 
                        resolve(); 
                    }; 
                }); 
            } catch (e) { 
                console.warn(e); 
            } 
        }

        // Clear the form states for this event's comment section.
        setCommentText(prev => ({ ...prev, [eventId]: '' }));
        setCommentImageUrl(prev => ({ ...prev, [eventId]: '' }));
        setShowCommentImageInput(prev => ({ ...prev, [eventId]: false }));
        
        // A full page reload is used here for simplicity to ensure the new comment appears correctly.
        window.location.reload();
    };

    // --- Render Helper Functions ---

    /**
     * Retrieves the display name for a host's pubkey.
     * @param pubkey The public key of the host.
     * @returns The user's name or a shortened pubkey.
     */
    const getHostName = (pubkey: string) => { 
        const profile = hostProfiles[pubkey]; 
        return profile?.name || pubkey.substring(0, 8) + '...'; 
    };

    /**
     * Retrieves the display name for a commenter's pubkey.
     * Checks commenter profiles first, then host profiles as a fallback.
     * @param pubkey The public key of the commenter.
     * @returns The user's name or a shortened pubkey.
     */
    const getCommenterName = (pubkey: string) => { 
        const profile = commenterProfiles[pubkey] || hostProfiles[pubkey]; 
        return profile?.name || pubkey.substring(0, 8) + '...'; 
    };
    
    /**
     * Renders comment content, embedding images if URLs are detected.
     * @param text The raw comment text.
     * @returns An array of strings and React elements to be rendered.
     */
    const renderContentWithImages = (text: string): (string | React.ReactElement)[] => {
        const urlRegex = /(https?:\/\/[^^\s]+)/g;
        const parts = []; // Type is inferred as (string | JSX.Element)[]
        let lastIndex = 0;
        let match;

        while ((match = urlRegex.exec(text)) !== null) {
            if (match.index > lastIndex) { 
                parts.push(text.substring(lastIndex, match.index)); 
            }
            const url = match[0];
            if (/\.(jpeg|jpg|gif|png|webp)(\?.*)?$/i.test(url)) { 
                parts.push(
                    <img 
                        key={url} 
                        src={url} 
                        alt="User embedded image" 
                        style={{ maxWidth: '100%', height: 'auto', borderRadius: '8px', marginTop: '10px', display: 'block' }} 
                    />
                ); 
            } else { 
                parts.push(url); 
            }
            lastIndex = urlRegex.lastIndex;
        }

        if (lastIndex < text.length) { 
            parts.push(text.substring(lastIndex)); 
        }

        return parts;
    };

    // --- Render Logic ---
    return (
        <div>
            <h2>Upcoming Agora Events</h2>
            <button onClick={() => setShowCreateForm(!showCreateForm)} style={{ marginBottom: '20px', padding: '10px 20px', cursor: 'pointer' }}>
                {showCreateForm ? 'Cancel' : 'Create New Event'}
            </button>
            {showCreateForm && (
                <form onSubmit={handleCreateEvent} style={{ border: '1px solid #ccc', padding: '20px', borderRadius: '8px', marginBottom: '20px' }}>
                    <input placeholder="Event Name" value={newEvent.name} onChange={(e) => setNewEvent({ ...newEvent, name: e.target.value })} required style={{ display: 'block', width: '98%', marginBottom: '10px', padding: '10px' }} />
                    <input placeholder="Location" value={newEvent.location} onChange={(e) => setNewEvent({ ...newEvent, location: e.target.value })} required style={{ display: 'block', width: '98%', marginBottom: '10px', padding: '10px' }} />
                    <input type="datetime-local" value={newEvent.startTime} onChange={(e) => setNewEvent({ ...newEvent, startTime: e.target.value })} required style={{ display: 'block', width: '98%', marginBottom: '10px', padding: '10px' }} />
                    <textarea placeholder="Description" value={newEvent.description} onChange={(e) => setNewEvent({ ...newEvent, description: e.target.value })} rows={4} style={{ display: 'block', width: '98%', marginBottom: '10px', padding: '10px' }} />
                    <input placeholder="Image URL (optional)" value={newEvent.image_url} onChange={(e) => setNewEvent({ ...newEvent, image_url: e.target.value })} style={{ display: 'block', width: '98%', marginBottom: '10px', padding: '10px' }} />
                    <button type="submit" style={{ padding: '10px 20px', cursor: 'pointer' }}>Share to Feed</button>
                </form>
            )}
            {isLoading ? (<p>Loading events...</p>) : (
                <div className="meetups-grid">
                    {events.length === 0 ? (<p>No upcoming events found. Be the first to create one!</p>) : (
                        events.map(event => {
                            const eventData = JSON.parse(event.content); 
                            const startTime = DateTime.fromISO(eventData.startTime); 
                            const eventRsvpsSet = rsvps[event.id] || new Set(); 
                            const eventRsvps = Array.from(eventRsvpsSet); 
                            const isHostFriend = friends.has(event.pubkey); 
                            const amIAttending = eventRsvpsSet.has(userPublicKey); 
                            const attendingFriends = eventRsvps.filter(rsvpPubkey => friends.has(rsvpPubkey) && rsvpPubkey !== userPublicKey); 
                            const isMyEvent = event.pubkey === userPublicKey; 
                            const eventComments = comments[event.id] || [];
                            
                            return (
                                <div key={event.id} className="meetup-card">
                                    {eventData.image_url && <img src={eventData.image_url} alt={eventData.name} className="event-image" />}
                                    <div className="card-content">
                                        <h3>{eventData.name}</h3>
                                        <p><strong>Where:</strong> {eventData.location}</p>
                                        <p><strong>When:</strong> {startTime.toLocaleString(DateTime.DATETIME_FULL)}</p>
                                        <p>{eventData.description}</p>
                                    </div>
                                    <div className="card-footer">
                                        <div>
                                            <span>Hosted by: {getHostName(event.pubkey)}</span>
                                            {isHostFriend && !isMyEvent && <span style={{ color: '#28a745', fontWeight: 'bold', marginLeft: '10px' }}>ü§ù Friend</span>}
                                        </div>
                                    </div>
                                    <div className="card-footer" style={{ borderTop: '1px solid #eee', paddingTop: '10px' }}>
                                        <div>
                                            <span>Attending ({eventRsvps.length})</span>
                                            {amIAttending && !isMyEvent && <span style={{ color: '#007bff', fontWeight: 'bold', marginLeft: '10px' }}>‚úì You're Going</span>}
                                            {attendingFriends.length > 0 && <span style={{ color: '#28a745', fontWeight: 'bold', marginLeft: '10px' }}>ü§ù {attendingFriends.length} Friend(s)</span>}
                                        </div>
                                        {isMyEvent ? (<span style={{ color: '#6c757d', fontWeight: 'bold' }}>Hosting</span>) : (<button onClick={() => handleToggleRSVP(event.id)} style={{ padding: '5px 10px', fontSize: '0.9em', cursor: 'pointer' }}>{amIAttending ? 'Cancel RSVP' : 'RSVP'}</button>)}
                                    </div>
                                    <div className="card-footer" style={{ borderTop: '1px solid #eee', paddingTop: '10px', flexDirection: 'column', alignItems: 'flex-start' }}>
                                        <h4 style={{ margin: '0 0 10px 0', width: '100%' }}>Comments ({eventComments.length})</h4>
                                        <div style={{ width: '100%', maxHeight: '200px', overflowY: 'auto', marginBottom: '10px' }}>
                                            {eventComments.length === 0 && <p style={{ fontSize: '0.9em', color: '#666' }}>No comments yet.</p>}
                                            {eventComments.map(comment => {
                                                const commenterName = getCommenterName(comment.pubkey); 
                                                const isCommenterFriend = friends.has(comment.pubkey);
                                                
                                                return (
                                                    <div key={comment.id} style={{ borderBottom: '1px solid #f0f0f0', paddingBottom: '8px', marginBottom: '8px' }}>
                                                        <strong>{commenterName}</strong>
                                                        {isCommenterFriend && <span style={{ color: '#28a745', fontWeight: 'bold', marginLeft: '5px' }}>ü§ù</span>}
                                                        <span style={{ float: 'right', fontSize: '0.8em', color: '#999' }}>{DateTime.fromSeconds(comment.created_at).toRelative()}</span>
                                                        <p style={{ margin: '5px 0 0 0', fontSize: '0.9em', whiteSpace: 'pre-wrap' }}>{renderContentWithImages(comment.content)}</p>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                        {/* --- Comment Input Section with Image Embedding --- */}
                                        <div style={{ width: '100%' }}>
                                            <textarea
                                                placeholder="Add a comment..."
                                                value={commentText[event.id] || ''}
                                                onChange={(e) => setCommentText({ ...commentText, [event.id]: e.target.value })}
                                                rows={3}
                                                style={{ width: '100%', marginBottom: '10px', padding: '8px', boxSizing: 'border-box', resize: 'vertical' }}
                                            />
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
                                                <button
                                                    onClick={() => setShowCommentImageInput(prev => ({ ...prev, [event.id]: !prev[event.id] }))}
                                                    style={{ padding: '5px 10px', cursor: 'pointer', fontSize: '0.9em' }}
                                                >
                                                    {showCommentImageInput[event.id] ? 'Cancel Image' : '+ Add Image'}
                                                </button>
                                            </div>
                                            {showCommentImageInput[event.id] && (
                                                <input
                                                    type="url"
                                                    placeholder="Image URL"
                                                    value={commentImageUrl[event.id] || ''}
                                                    onChange={(e) => setCommentImageUrl({ ...commentImageUrl, [event.id]: e.target.value })}
                                                    style={{ display: 'block', width: '100%', marginBottom: '10px', padding: '8px', boxSizing: 'border-box' }}
                                                />
                                            )}
                                            <div style={{ display: 'flex', justifyContent: 'flex-end' }}>
                                                <button onClick={() => handlePostComment(event.id)} style={{ padding: '8px 12px', cursor: 'pointer' }}>Post</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            );
                        })
                    )}
                </div>
            )}
            {!isLoading && hasMoreEvents && events.length > 0 && (
                <div style={{ textAlign: 'center', marginTop: '30px' }}>
                    <button onClick={handleLoadMore} disabled={isLoadingMore} style={{ padding: '10px 20px', cursor: isLoadingMore ? 'not-allowed' : 'pointer', opacity: isLoadingMore ? 0.6 : 1 }}>
                        {isLoadingMore ? 'Loading...' : 'Load More'}
                    </button>
                </div>
            )}
        </div>
    );
};

export default HomePage;
